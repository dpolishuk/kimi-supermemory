{"id":"kimi-supermemory-22v","title":"Task 4: Create TROUBLESHOOTING.md","design":"## Goal\nCreate structured troubleshooting guide with error-cause-solution format for 8+ common installation and usage issues.\n\n## Effort Estimate\n2-3 hours\n\n## Success Criteria\n- [ ] TROUBLESHOOTING.md covers 8+ common issues\n- [ ] Each issue has Error message, Cause, Solutions\n- [ ] Includes verification commands for each fix\n- [ ] Links to external docs where appropriate\n- [ ] References debug logging\n- [ ] QUICKSTART.md links to TROUBLESHOOTING.md\n- [ ] Manual test: Can follow any error → solution\n\n## Implementation\n\n1. Create TROUBLESHOOTING.md\n2. Add 8+ issues:\n   - npm permission errors\n   - kimi CLI not found\n   - API key not recognized\n   - MCP server not loading\n   - npm install hangs\n   - Skill not appearing\n   - Verify installation test\n   - Enable debug logging\n3. For each: Error → Cause → Solutions with commands\n4. Add final section: Still stuck? Enable debug logs\n\n## Key Considerations\n\n**Edge Case: Multiple solutions**\n- Provide options (NVM, fix permissions, use package manager)\n- Clear pros/cons for each\n\n**Edge Case: External dependencies**\n- kimi CLI installation not our scope\n- Link to docs, don't try to handle ourselves\n\n## Anti-patterns\n- ❌ NO vague solutions (exact commands only)\n- ❌ NO assuming prior knowledge (explain steps)\n- ❌ NO platform-specific hacks (keep solutions clean)\n- ❌ NO security risks (no suggesting sudo, etc.)","status":"closed","priority":1,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T21:55:05.93369+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T21:55:36.519397+03:00","closed_at":"2026-02-05T21:55:36.519397+03:00","close_reason":"Closed","dependencies":[{"issue_id":"kimi-supermemory-22v","depends_on_id":"kimi-supermemory-89c","type":"blocks","created_at":"2026-02-05T21:55:11.2165+03:00","created_by":"Dmitry Polishuk"}]}
{"id":"kimi-supermemory-4t2","title":"Task 2: Create uninstall.sh script for clean removal","description":"Create uninstall.sh script for clean removal of kimi-supermemory installation including MCP server, skill, and optional config files","design":"## Goal\nCreate uninstall.sh script that cleanly removes kimi-supermemory components with optional configuration cleanup.\n\n## Effort Estimate\n2-3 hours\n\n## Success Criteria\n- [ ] uninstall.sh removes MCP server via kimi mcp remove supermemory\n- [ ] uninstall.sh removes skill directory\n- [ ] uninstall.sh --clean-config removes config files\n- [ ] Script provides color-coded feedback (GREEN=success, YELLOW=warning, RED=error)\n- [ ] Script handles gracefully if components not already installed\n- [ ] Script checks for permission errors and provides helpful messages\n- [ ] Manual test: ./uninstall.sh removes successfully\n- [ ] Manual test: ./uninstall.sh --clean-config removes everything\n- [ ] Syntax check: bash -n uninstall.sh passes\n\n## Implementation\n\n1. Create uninstall.sh in project root\n2. Add color variables (matching install.sh)\n3. Add MCP server removal with error handling\n4. Add skill directory removal with error handling\n5. Add optional --clean-config flag handling\n6. Add helpful messages for env var cleanup\n7. Test normal mode and --clean-config mode\n\n## Key Considerations\n\n**Edge Case: MCP Server Not Found**\n- If mcp remove fails, don't crash\n- Check if kimi mcp list shows supermemory\n- Continue with skill removal even if MCP not found\n\n**Edge Case: Skill Directory Missing**\n- If SKILL_DIR missing, handle gracefully\n- Check if directory exists before removing\n- Report message but don't error (idempotent removal)\n\n**Edge Case: Config File Permission Errors**\n- config files may fail if permissions issue\n- Handle errors with helpful error\n- Tell user to manually check permissions\n\n## Anti-patterns\n- ❌ No silent failures (report what happened)\n- ❌ No modifying env vars (user can handle env vars themselves)\n- ❌ No assuming components exist (check first)\n- ❌ No sudo commands (should work with user permissions)","status":"closed","priority":1,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T21:53:54.525366+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T21:54:31.059369+03:00","closed_at":"2026-02-05T21:54:31.059369+03:00","close_reason":"Closed","dependencies":[{"issue_id":"kimi-supermemory-4t2","depends_on_id":"kimi-supermemory-8jy","type":"parent-child","created_at":"2026-02-05T21:53:58.973179+03:00","created_by":"Dmitry Polishuk"},{"issue_id":"kimi-supermemory-4t2","depends_on_id":"kimi-supermemory-5h1","type":"blocks","created_at":"2026-02-05T21:53:59.050648+03:00","created_by":"Dmitry Polishuk"}]}
{"id":"kimi-supermemory-5h1","title":"Task 1: Enhance install.sh with verification and error handling","description":"Enhance install.sh to provide verification steps so users can confirm installation succeeded","design":"## Goal\nAdd verification steps to install.sh so users can confirm installation succeeded and get clear error guidance if it fails.\n\n## Effort Estimate\n4-6 hours\n\n## Success Criteria\n- [ ] install.sh exits with code 0 on all successful paths\n- [ ] install.sh exits with code 1 on any failure (MCP registration, skill copy, server test)\n- [ ] kimi mcp list shows 'supermemory' entry after successful install\n- [ ] ~/.config/agents/skills/kimi-supermemory/SKILL.md exists after successful install\n- [ ] MCP server test passes (node SERVER_PATH 2\u003e\u00261 | grep 'running on stdio')\n- [ ] Error messages use color coding: RED for errors (✗), YELLOW for warnings (⚠️), GREEN for success (✓)\n- [ ] Unit tests in mcp-server/test/ pass (13 tests total)\n- [ ] Manual verification: ./install.sh → test exit code with 'echo $?'\n- [ ] Pre-commit hooks pass: npm test \u0026\u0026 git lint\n\n## Implementation\n\n1. Study existing install.sh (1-80 lines understand flow)\n2. After kimi mcp registration (line 49), add verification code:\n   ```bash\n   # Verify MCP server is working\n   echo -e \"\\Verifying MCP server...\\\"\n   if ! command -v kimi \u0026\u003e /dev/null; then\n     echo -e \"\\✗ kimi CLI not found. Install kimi CLI first: https://github.com/MoonshotAI/kimi-cli\\\"\n     exit 1\n   fi\n   \n   if kimi mcp list 2\u003e\u00261 | grep -q \"supermemory\"; then\n     echo -e \"\\✓ MCP server registered successfully\\\"\n   else\n     echo -e \"\\✗ MCP server registration failed. Run 'kimi mcp list' to diagnose.\\\"\n     exit 1\n   fi\n   \n   # Verify skill installation\n   echo -e \"\\Verifying skill installation...\\\"\n   if [ -f \"\\/SKILL.md\" ]; then\n     echo -e \"\\✓ Skill installed at \\\"\n   else\n     echo -e \"\\✗ Skill installation failed. Check directory exists: \\\"\n     exit 1\n   fi\n   ```\n\n3. Post-API key warning, before success message:\n   ```bash\n   # If API key set, verify MCP server loads\n   if [ -n \"\\sm_UvHYkv16C65MdAWEStZB5d_ZUatpUuhBPFPJCrDinJSzFRjBLlQPQOyNdmHtzbMkeahzddWTDPClAeBkwEQmqDS\" ]; then\n     echo -e \"\\Testing MCP server startup...\\\"\n     # Timeout 5s to avoid hanging\n     timeout 5s node \"\\\" 2\u003e\u00261 | grep -q \"running on stdio\" \u0026\u0026 \\\n       echo -e \"\\✓ MCP server test passed\\\" || \\\n       echo -e \"\\⚠️  MCP server test skipped (may need interactive session)\\\"\n   fi\n   ```\n\n4. Add -e flag to #!/bin/bash (line 1):\n   ```bash\n   # Change from '#!/bin/bash' to '#!/bin/bash -e'\n   # Causes script to exit on any command failure\n   ```\n\n## Key Considerations\n\n**Edge Case: kimi CLI Not Found** (Critical blocking issue)\n- Commands kimi mcp assume kimi CLI installed\n- Without check, cryptic \"command not found\" error\n- MUST verify command -v kimi before using\n- Provide helpful error with installation instructions\n\n**Edge Case: Node Not Found Wrong Version** (Blocking issue)\n- Script assumes node is installed (not checked)\n- Node 18+ required but path may have older version\n- MUST check node --version matches requirement\n- Provide helpful error message if version mismatch\n\n**Edge Case: SERVER_PATH InvalidEmpty** (Data corruption issue)\n- SERVER_PATH variable may be empty if build fails silently\n- Node command with empty path causes confusing error\n- MUST validate SERVER_PATH exists and is executable\n- Check: [ -f \"\\\" ] \u0026\u0026 [ -x \"\\\" ]\n\n**Edge Case: SKILL.md Copy Fails Due to Permissions** (Partial installation state)\n- cp command may fail silently if no write permission\n- User thinks installation succeeded but skill missing\n- MUST capture cp exit code and handle failure\n- Provide helpful error: \"Check write permissions for ~/.config/agents/skills/\"\n\n## Anti-patterns\n- ❌ No silent failures (exit 1 on any issue, don't continue)\n- ❌ No confusing error messages (be specific: what failed, why, what to do)\n- ❌ No indefinite hangs (use timeout on node execution)\n- ❌ No undefined variable expansion (check SERVER_PATH before use)\n- ❌ No assuming commands exist (use command -v before kimi, node)","status":"closed","priority":1,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T21:52:38.583055+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T21:53:36.810959+03:00","closed_at":"2026-02-05T21:53:36.810959+03:00","close_reason":"Closed","dependencies":[{"issue_id":"kimi-supermemory-5h1","depends_on_id":"kimi-supermemory-8jy","type":"parent-child","created_at":"2026-02-05T21:52:41.140163+03:00","created_by":"Dmitry Polishuk"}]}
{"id":"kimi-supermemory-6tb","title":"Task 1: Build configuration system and logging service","design":"## Goal\nBuild foundational infrastructure: configuration system and logging service. These services are prerequisites for all other tools and services in the epic. Configuration loader handles XDG config directories, JSON parsing, env variable overrides, and graceful degradation. Logger provides structured logging to file with timestamped entries and multiple log levels.\n\n## Implementation\n\n1. **Study existing code**\n   - Review mcp-server/src/supermemory-client.js to understand client pattern\n   - Review mcp-server/src/supermemory-client.js environment variable usage\n   - Note: current implementation reads API key from process.env.SUPERMEMORY_API_KEY\n\n2. **Write tests first (TDD)**\n   - Create tests for config loading (config file, defaults, env override)\n   - Create tests for logging (timestamp format, log levels, file writing)\n   - Create tests for XDG config dir detection\n\n3. **Implementation checklist**\n   - mcp-server/src/services/config.ts - Configuration loader with XDG detection, DEFAULTS, env override\n   - mcp-server/src/services/logger.ts - Structured logging to ~/.kimi-supermemory.log (logInfo, logWarn, logError, logDebug)\n   - Tests in mcp-server/test/config.test.ts and mcp-server/test/logger.test.ts\n   - Integration test: Verify config loads correctly and logs write to file\n\n## Success Criteria\n\n**Configuration Loading**:\n- [ ] Config loads correctly from ~/.config/kimi/supermemory.jsonc when present\n- [ ] Config loads from ~/.kimi/supermemory.json as fallback when .jsonc not found\n- [ ] Environment variable SUPERMEMORY_API_KEY overrides config file apiKey\n- [ ] Environment variable SUPERMEMORY_API_URL overrides config file apiUrl\n- [ ] DEFAULTS applied when config file missing or invalid JSON\n- [ ] Invalid JSON in config file logged as warning and defaults used (no crash)\n\n**Logging Functionality**:\n- [ ] Logging writes to ~/.kimi-supermemory.log with ISO timestamp [2026-02-05T12:30:45.123Z]\n- [ ] All 4 log levels (INFO, WARN, ERROR, DEBUG) working correctly with proper formatting\n- [ ] Log file directory created automatically if missing (mkdir with recursive: true)\n- [ ] Log write failures to stderr fallback (degrade gracefully, no crash)\n- [ ] logDebug() only writes when DEBUG_MODE enabled (filtering in prod)\n\n**Test Coverage**:\n- [ ] 12+ unit tests pass covering config and logger edge cases\n- [ ] npm test passes with all tests green\n- [ ] npm run lint passes eslint checks\n- [ ] npm run typecheck passes TypeScript validation\n\n## Detailed Steps\n\n**Step 1: Create config service**\n- Define SupermemoryConfig interface (apiKey, apiUrl, similarityThreshold, maxMemories, maxProjectMemories, maxProfileItems, injectProfile, containerTagPrefix, keywordPatterns, debug, allowPrivateContent)\n- Implement getHomeConfigDir() to detect ~/.config/kimi or ~/.kimi (XDG standard preference)\n- Implement loadConfig() with XDG detection in CONFIG_FILES order: ~/.config/kimi/supermemory.jsonc → ~/.config/kimi/supermemory.json → ~/.kimi/supermemory.jsonc → ~/.kimi/supermemory.json\n- Apply DEFAULTS for all values (except apiKey which may be in env)\n- Read JSON from config files, handle JSON.parse errors gracefully\n- Override with env vars: SUPERMEMORY_API_KEY, SUPERMEMORY_API_URL\n- Test config loading with valid files, invalid JSON, missing files, env overrides\n\n**Step 2: Create logger service**\n- Define log file path: ~/.kimi-supermemory.log\n- Implement log() with timestamp (ISO format toISOString()) + level + message + optional JSON data\n- Implement logInfo(), logWarn(), logError(), logDebug() helpers\n- Add ensureLogFile() to create directory if needed (mkdirSync with recursive: true, catch errors)\n- Add graceful error handling: if fs.appendFileSync fails, log to stderr instead\n\n**Step 3: Write tests**\n- **test/config.test.ts**:\n  - test_config_loads_from_jsonc_file: Loads valid JSONC with all fields\n  - test_config_loads_from_json_fallback: Falls back to .json when .jsonc missing\n  - test_env_override_apiKey: SUPERMEMORY_API_KEY overrides config file\n  - test_env_override_apiUrl: SUPERMEMORY_API_URL overrides config file\n  - test_invalid_json_uses_defaults: Invalid JSON logged as warning, defaults used\n  - test_missing_file_uses_defaults: No config file found, defaults used\n  - test_xdg_config_dir_preferred: ~/.config/kimi checked before ~/.kimi\n  \n- **test/logger.test.ts**:\n  - test_log_format_timestamp_iso: Timestamp in ISO 8601 format\n  - test_log_levels_formatted_correctly: INFO, WARN, ERROR, DEBUG prefixed correctly\n  - test_log_creates_directory: Creates parent directory if missing\n  - test_log_writes_to_file: Content written to ~/.kimi-supermemory.log\n  - test_log_debug_only_when_enabled: DEBUG logs only when debugMode=true\n  - test_log_write_fails_gracefully: fs.appendFileSync error falls back to stderr without crash\n\n**Step 4: Integration**\n- Update server.js to load config on startup\n- Use Config.loadConfig() to initialize configuration\n- Use config.similarityThreshold, maxMemories, etc. in tool handlers\n- Call logger.logInfo() on successful server startup\n- Call logger.logError() on failures (catch Error, log message, don't throw)\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO crash on invalid JSON (reasoning: Must degrade gracefully with defaults)\n- ❌ NO crash on missing config file (reasoning: Must use defaults, not fail)\n- ❌ NO crash on permission errors (reasoning: Log warning, use defaults/no-op)\n- ❌ NO synchronous file I/O in hot path (reasoning: Config loads once at startup, logging is async-safe)\n- ❌ NO environment variable validation on every read (reasoning: Check once at loadConfig() startup)\n- ❌ NO unwrapping JSON.parse without try-catch (reasoning: Invalid JSON shouldn't crash MCP server)\n- ❌ NO assuming XDG_DIR exists (reasoning: Check existence, create if missing, handle permission errors)\n\n## Key Considerations\n\n**Config File Edge Cases**:\n- What happens if config directory doesn't exist? → Create parent directories with recursive: true, catch permission errors\n- What if config file has invalid JSON? → JSON.parse throws, catch Error, logWarning, use DEFAULTS, don't crash\n- What if JSONC has comments? → Strip // and /**/ comments before JSON.parse (JSONC format)\n- What if config file permission denied? → Log error to stderr, use DEFAULTS, don't crash\n\n** Logging Edge Cases**:\n- What happens if log directory doesn't exist? → mkdirSync with recursive: true, catch permission errors, degrade gracefully\n- What if log file write permission denied? → Use try-catch on fs.appendFileSync, log to stderr as fallback, don't crash\n- What if logs grow too large? → Log rotation not in initial scope, document in README\n- What if concurrent writes conflict? → fs.appendFileSync atomic on POSIX, document in logger docstring\n\n**Error Handling Strategy**:\n- Use try-catch around all fs operations\n- Never throw from config loading or logging (caller may not handle)\n- Always log errors to stderr as ultimate fallback\n- Degrade gracefully: missing config → DEFAULTS, logging failure → stderr only\n\n**Performance Considerations**:\n- Config loads once at startup (\u003c50ms), acceptable for MCP server start time\n- Logging uses fs.appendFileSync (simpler than async), acceptable since log volume low (\u003c1MB/session)\n- XDG config detection on startup, check 2 directories, fast operation\n\n**Reference Implementation**:\n- Study opencode-supermemory src/config.ts for pattern to follow (XDG detection, JSONC parsing, error handling)","status":"closed","priority":0,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T13:15:08.677492+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T13:41:16.202743+03:00","closed_at":"2026-02-05T13:41:16.202743+03:00","close_reason":"Closed","dependencies":[{"issue_id":"kimi-supermemory-6tb","depends_on_id":"kimi-supermemory-sxo","type":"parent-child","created_at":"2026-02-05T13:15:12.242174+03:00","created_by":"Dmitry Polishuk"}]}
{"id":"kimi-supermemory-89c","title":"Task 3: Create QUICKSTART.md one-page guide","description":"Create QUICKSTART.md one-page guide for getting started with kimi-supermemory in under 30 seconds","design":"## Goal\nCreate one-page QUICKSTART.md guide covering install → API key → verify → use workflow for end users.\n\n## Effort Estimate\n1-2 hours\n\n## Success Criteria\n- [ ] QUICKSTART.md is one page (~40 lines)\n- [ ] Covers install, API key, verify, first run sections\n- [ ] All commands are copy-paste ready\n- [ ] Auto-detects user's shell (bash/zsh)\n- [ ] Includes verification commands\n- [ ] Links to TROUBLESHOOTING.md for help\n- [ ] README.md references QUICKSTART.md\n- [ ] Manual test: Follow guide end-to-end successfully\n\n## Implementation\n\n1. Create QUICKSTART.md in project root\n2. Section 1: Install (one-line command)\n3. Section 2: API key setup (shell check + commands)\n4. Section 3: Verify installation (kimi mcp list)\n5. Section 4: First run (instructions)\n6. Section 5: Getting help (links)\n\n## Key Considerations\n\n**Edge Case: Shell Detection**\n- User may have bash or zsh\n- Provide both ~/.bashrc and ~/.zshrc instructions\n- Auto-detect with echo $SHELL if possible\n\n**Edge Case: Verification Fails**\n- User runs kimi mcp list and nothing shows\n- Include troubleshooting link\n\n## Anti-patterns\n- ❌ NO placeholder paths (e.g., /path/to/server.cjs)\n- ❌ NO vague instructions (use exact commands)\n- ❌ NO assuming user knows how to edit files (provide echo commands)\n- ❌ NO referencing complex docs (keep to one page)","status":"closed","priority":1,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T21:54:34.756201+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T21:54:47.341398+03:00","closed_at":"2026-02-05T21:54:47.341398+03:00","close_reason":"Closed"}
{"id":"kimi-supermemory-8jy","title":"Epic: Comprehensive installation instructions and guides","description":"Create comprehensive installation instructions for end users including verification, uninstall, quick start, and troubleshooting guides","design":"## Requirements (IMMUTABLE)\n- Users can verify installation succeeded (MCP server, skill, API key)\n- Users have clear step-by-step instructions to uninstall cleanly\n- Users have one-page quick reference guide for getting started\n- Users have structured troubleshooting guide for common issues\n- API key setup instructions auto-detect user's shell (bash/zsh)\n- All guides include verification commands to test functionality\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] install.sh passes verification tests (MCP server registered, skill installed)\n- [ ] uninstall.sh removes MCP server, skill, and optional config\n- [ ] QUICKSTART.md is one page and covers install → API key → verify → use\n- [ ] TROUBLESHOOTING.md covers 8+ common issues with solutions\n- [ ] All scripts handle errors gracefully\n- [ ] CLI commands are tested and work as documented\n- [ ] Documentation links where appropriate (external guides, issues)\n- [ ] All tests passing\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO sudo in install.sh (reasoning: breaks file permissions, causes future npm issues)\n- ❌ NO assuming shell type (reasoning: bash and zsh have different config files)\n- ❌ NO placeholder commands without verification (reasoning: /path/to/server.cjs doesn't work)\n- ❌ NO troubleshooting without error message context (reasoning: user can't match their error)\n- ❌ NO API key secrets in documentation (reasoning: security risk, even in examples)\n- ❌ NO version-specific paths (reasoning: breaks with Node.js or OS updates)\n\n## Approach\nCreate end-user focused documentation and scripts:\n1. Enhance install.sh with verification steps and error handling\n2. Create uninstall.sh for clean removal with --clean-config option\n3. Create QUICKSTART.md as one-page quick reference guide\n4. Create TROUBLESHOOTING.md with structured error → cause → solution format\n5. Add API key setup instructions with shell detection\n6. Include verification commands throughout\n\n## Architecture\n- install.sh: Prerequisites → Build → Register MCP → Install skill → Verify → Success message\n- uninstall.sh: Remove MCP → Remove skill → Optional config cleanup → Success message\n- QUICKSTART.md: Install → API key → Verify → First run → Getting help\n- TROUBLESHOOTING.md: Each issue = Error message → Cause → Solution steps → Test\n\n## Design Rationale\n### Problem\nCurrent installation experience lacks verification, uninstall procedures, and troubleshooting guidance. Users install but can't confirm it works. Encountering errors means no recovery path. API key setup is confusing.\n\n### Research Findings\n**Codebase:**\n- install.sh:80 lines - Current script, has basic checks but no verification\n- skill/SKILL.md:129 lines - Has installation info but not focused on quick start\n- README.md:175 lines - Has prerequisites and manual setup\n- Package.json has npm test scripts for verification\n\n**External:**\n- Kimi CLI docs - Uses ~/.kimi/mcp.json for MCP config, supports kimi mcp add/remove commands\n- NVM solves npm permission issues (40+ hours saved according to research)\n- Supermemory API requires sm_ prefix for keys\n- Common npm errors: EACCES permission denied, cache corruption, network issues\n- Shell detection needed: bash (~/.bashrc), zsh (~/.zshrc)\n\n### Approaches Considered\n1. **Separate files (install.sh, uninstall.sh, QUICKSTART.md, TROUBLESHOOTING.md)** ✓\n   - Pros: Focused, easy to update, follows existing pattern\n   - Cons: More files to maintain\n   - **Chosen because:** Each file has clear purpose, easier for users to find what they need\n\n2. **Single SETUP.md with all instructions**\n   - Pros: One file to update\n   - Cons: Too long, hard to navigate, mixes quick start with deep troubleshooting\n   - **Rejected because:** Users get overwhelmed, can't find what they need quickly\n\n3. **Enhance existing install.sh only**\n   - Pros: Single script file\n   - Cons: Mixes code and docs, uninstall not addressed, missing troubleshooting\n   - **Rejected because:** Doesn't solve recovery path or verification for end users\n\n### Scope Boundaries\n**In scope:**\n- End-user installation verification (end users = first priority)\n- Uninstall instructions\n- API key setup with shell detection\n- Troubleshooting guide for 8+ common issues\n- One-page quick reference\n\n**Out of scope (deferred/never):**\n- Windows support (bash-script focus, Windows PowerShell requires separate work)\n- CI/CD documentation (end users are primary audience, not automation)\n- Version management and upgrade paths (deferred to future epic)\n- Developer setup guide (contributors are secondary priority)\n\n### Open Questions\n- Should verification be part of install.sh or separate verify-install.sh? (Decision: install.sh for simplicity)\n- Should --clean-config in uninstall.sh remove logs? (Decision: yes, logs contain session data)\n- Should QUICKSTART.md link to full SKILL.md? (Decision: no, keep one-page, mention SKILL.md as reference)\n\n## Files to Create/Modify\n- install.sh (modify - add 10 lines of verification)\n- uninstall.sh (create - ~30 lines)\n- QUICKSTART.md (create - ~40 lines)\n- TROUBLESHOOTING.md (create - ~150 lines)\n- Update README.md to link to QUICKSTART.md","status":"closed","priority":1,"issue_type":"epic","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T21:52:17.505785+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T22:06:22.840126+03:00","closed_at":"2026-02-05T22:06:22.840126+03:00","close_reason":"Closed"}
{"id":"kimi-supermemory-fof","title":"Task 2: Add hash-based scoping services (tags.ts)","design":"\n## Goal\nBuild hash-based scoping system for user and project memory organization. User tags use KIMI_EMAIL (fallback to USER/USERNAME). Project tags parse git remote URL from .git/config, normalize URLs, and hash for cross-machine consistency. Fallback to directory name if git remote unavailable.\n\n## Implementation\n1. Create mcp-server/src/services/tags.ts\n2. Implement sha256() hash function\n3. Implement getUserTag() using KIMI_EMAIL or USER/USERNAME\n4. Implement getGitRemoteUrl() with .git/config parsing\n5. Implement normalizeGitUrl() (strip auth, standardize format)\n6. Implement getProjectTag() from git remote or directory name\n7. Tests for all functions\n\n## Success Criteria\n- getUserTag() generates kimi_user_{hash} from KIMI_EMAIL\n- getUserTag() fallback to USER or USERNAME env vars\n- getGitRemoteUrl() parses .git/config correctly\n- normalizeGitUrl() handles HTTPS, SSH, credential stripping\n- normalizeGitUrl() produces same hash for same repo across machines\n- getProjectTag() falls back to directory name for non-git repos\n- All 8+ tests passing\n\n## Anti-patterns\n- NO shell command execution from MCP server (reasoning: Use fs.readFile for .git/config)\n- NO hardcoded paths (reasoning: Use cwd parameter)\n- NO crash on .git config parse failure (reasoning: Fallback gracefully)\n- NO assuming git is installed (reasoning: May be non-git project)\n","status":"closed","priority":0,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T13:41:29.937416+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T14:02:00.101574+03:00","closed_at":"2026-02-05T14:02:00.101574+03:00","close_reason":"Closed"}
{"id":"kimi-supermemory-nv2","title":"Task 3: Add privacy filtering service (privacy.ts)","design":"\n## Goal\nImplement privacy filtering system to strip \u003cprivate\u003e tags from memory content before saving to Supermemory API, and reject fully-private content. Prevent any private information from being stored externally.\n\n## Implementation\n1. Create mcp-server/src/services/privacy.ts\n2. Implement containsPrivateTag() - regex detection of \u003cprivate\u003e...\u003c/private\u003e patterns\n3. Implement stripPrivateContent() - replaces \u003cprivate\u003e tags with [REDACTED]\n4. Implement isFullyPrivate() - checks if content is entirely private\n5. Implement hasNonPrivateContent() - validates mixed content has public parts\n6. Tests for all functions with edge cases (empty, fully-private, mixed, malformed)\n\n## Success Criteria\n- containsPrivateTag detects \u003cprivate\u003e...\u003c/private\u003e (case-insensitive)\n- stripPrivateContent replaces \u003cprivate\u003e content with \"[REDACTED]\"\n- isFullyPrivate returns true if only [REDACTED] placeholder remains\n- isFullyPrivate returns true for empty string after stripping\n- hasNonPrivateContent identifies mixed public/private content\n- All 8+ tests passing\n\n## Anti-patterns\n- NO storing \u003cprivate\u003e content (reasoning: must protect PII, credentials, secrets)\n- NO returning original content after stripping (reasoning: caller must use stripped version)\n- NO partial redaction (reasoning: full content inside \u003cprivate\u003e is sensitive)\n- NO logging private content (reasoning: may leak secrets to log files)\n\n## Key Considerations\n- \u003cprivate\u003e tags are case-insensitive: \u003cPRIVATE\u003e\u003c/PRIVATE\u003e should be detected\n- Nested \u003cprivate\u003e tags should be handled\n- Empty \u003cprivate\u003e\u003c/private\u003e should be removed and content treated as private\n- Whitespace-only content inside tags is still private\n","status":"closed","priority":0,"issue_type":"feature","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T13:55:06.554258+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T14:01:51.736994+03:00","closed_at":"2026-02-05T14:01:51.736994+03:00","close_reason":"Closed"}
{"id":"kimi-supermemory-sxo","title":"Epic: Kimi Supermemory Feature Parity","design":"## Requirements (IMMUTABLE)\n- MCP server exposes 6 tools: add, search, get_context, list, forget, profile\n- supermemory_add requires: content, type (enum of 6 types), optional scope (user/project) defaults to project\n- supermemory_search supports: query, optional types filter, optional scope (user/project/all)\n- supermemory_get_context fetches user profile and project/context memories by cwd\n- supermemory_forget deletes memory by ID\n- supermemory_profile returns user profile facts (static/dynamic)\n- Hash-based scoping: User tag from KIMI_EMAIL env var, Project tag from git remote URL or directory name\n- Privacy: Strip \u003cprivate\u003e tags, reject fully-private content (sanitized empty)\n- Configuration: JSONC file (~/.config/kimi/supermemory.jsonc) with env var fallback, config supports keywordPatterns, similarityThreshold, limits, etc.\n- Logging: Structured logs to ~/.kimi-supermemory.log (timestamped JSON lines)\n- SKILL.md: Enhanced with memory types (6), scope guidelines, privacy examples, all 6 tools documented\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] MCP server compiles (npm run build) and can be added via kimi mcp add\n- [ ] supermemory_add saves memory with type metadata, strips \u003cprivate\u003e tags, rejects fully-private content\n- [ ] supermemory_search filters by type/scope correctly, returns formatted results with similarity percentages\n- [ ] supermemory_get_context returns profile + project/context memories formatted as \u003csupermemory-context\u003e\n- [ ] User tag generated from KIMI_EMAIL (fallback to USERNAME), Project tag from git remote URL (fallback to directory name)\n- [ ] Configuration file loaded from ~/.config/kimi/supermemory.jsonc or ~/.kimi/supermemory.json with DEFAULTS\n- [ ] Logging writes to ~/.kimi-supermemory.log with timestamps and log levels (INFO, WARN, ERROR, DEBUG)\n- [ ] All 6 tools tested with sample data\n- [ ] Pre-commit hooks passing\n- [ ] Install script works (chmod +x install.sh; ./install.sh sets up MCP + skill)\n\n## Anti-Patterns (FORBIDDEN)\n- NO automatic hooks implementation (reasoning: kimi-cli does not support hooks, must be manual/agent-driven)\n- NO session start hooks (reasoning: Kimi CLI has no hook system, cannot auto-inject context)\n- NO keyword-based auto-save (reasoning: No pattern matching hooks in kimi-cli, must rely on SKILL.md guidance)\n- NO compaction hooks (reasoning: Kimi CLI has no compaction hooks, cannot preserve context across compaction)\n- NO shell command execution in MCP server (reasoning: MCP stdio server cannot access git config, use KIMI_EMAIL env var instead)\n- Hardcoded paths (reasoning: Use XDG config dir and env vars for cross-platform compatibility)\n- Skipping privacy filtering (reasoning: Must always strip \u003cprivate\u003e tags and reject fully-private content)\n- Logging to stdout (reasoning: Logs go to ~/.kimi-supermemory.log file only, stderr for startup only)\n\n## Approach\nImplement enhanced MCP server with 6 tools, hash-based scoping, privacy filtering, configuration system, logging, and comprehensive SKILL.md documentation. Build on existing supermemory client library, add new services modules (tags.ts, privacy.ts, config.ts, logger.ts), and update server.js with new tool handlers.\n\n## Architecture\n- MCP server (stdio) with 6 tools configured in mcp-server/src/server.js\n- SupermemoryClient extended with profile/forget methods\n- New services: src/services/tags.ts (hash-based scoping), src/services/privacy.ts (privacy filtering), src/services/config.ts (config loading), src/services/logger.ts (structured logging)\n- Enhanced SKILL.md with memory types, scope guidelines, privacy examples, workflow guidance\n- Configuration: ~/.config/kimi/supermemory.jsonc supporting all config options with env var fallback\n- Dependencies: supermemory npm package, @modelcontextprotocol/sdk, node:crypto, node:fs\n\n## Data Flow\nManual flow only: User invokes skill or agent decides. Agent calls tools manually when needed. No automatic hooks.\n\n## Design Rationale\n### Problem\nkimi-supermemory currently in MVP stage with basic tools only. Need feature parity with opencode-supermemory.\n\n### Research Findings\n**Codebase:** mcp-server/src/server.js, supermemory-client.js, skill/SKILL.md, install.sh\n**External:** opencode-supermemory (feature-complete), kimi-cli (NO hooks system)\n\n### Approaches Considered\n1. **Enhanced Skill + MCP** ✓ (Chosen - works within constraints)\n2. Flow Skill Workflows (Rejected - more complex)\n3. Wait for Hooks (Rejected - not available)\n\n### Scope Boundaries\n**In scope:** 6 tools, 6 memory types, hash-based scoping, privacy, config, logging, SKILL.md\n**Out of scope:** Automatic hooks, keyword auto-save, compaction hooks (deferred/never)\n\n### Open Questions\n- KIMI_EMAIL fallback (Decision: use USER/USERNAME or anonymous)\n- Config file permission errors (Decision: log warning, use defaults)","status":"closed","priority":0,"issue_type":"epic","owner":"dmitry.polishuk@gmail.com","created_at":"2026-02-05T13:14:49.283702+03:00","created_by":"Dmitry Polishuk","updated_at":"2026-02-05T14:08:28.431228+03:00","closed_at":"2026-02-05T14:08:28.431228+03:00","close_reason":"Closed"}
